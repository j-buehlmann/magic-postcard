import { Requester } from "./http.js";
import { Topics } from "./topics.js";
import { Messages } from "./messages.js";
import { Schedules } from "./schedules.js";
import { Endpoints } from "./endpoints.js";
import type { Log } from "./types.js";
import type { BodyInit, HeadersInit } from "../../deps/raw.githubusercontent.com/microsoft/TypeScript/main/lib/lib.dom";
export declare type ClientConfig = {
    /**
     * Url of the qstash api server.
     *
     * This is only used for testing.
     *
     * @default "https://qstash.upstash.io"
     */
    baseUrl?: string;
    /**
     * The authorization token from the upstash console.
     */
    token: string;
};
declare type Destination = {
    /**
     * The url of a publicly accessible server where you want to send this message to.
     * The url must have a valid scheme (http or https).
     */
    url: string;
    topic?: never;
} | {
    url?: never;
    /**
     * Either the name or id of a topic to send this message to.
     */
    topic: string;
};
export declare type PublishRequest = Destination & {
    /**
     * The message to send.
     *
     * This can be anything, but please set the `Content-Type` header accordingly.
     *
     * You can leave this empty if you want to send a message with no body.
     */
    body?: BodyInit;
    /**
     * Optionally send along headers with the message.
     * These headers will be sent to your destination.
     *
     * We highly recommend sending a `Content-Type` header along, as this will help your destination
     * server to understand the content of the message.
     */
    headers?: HeadersInit;
    /**
     * Optionally delay the delivery of this message.
     *
     * In seconds.
     *
     * @default undefined
     */
    delay?: number;
    /**
     * Optionally set the absolute delay of this message.
     * This will override the delay option.
     * The message will not delivered until the specified time.
     *
     * Unix timestamp in seconds.
     *
     * @default undefined
     */
    notBefore?: number;
    /**
     * Provide a unique id for deduplication. This id will be used to detect duplicate messages.
     * If a duplicate message is detected, the request will be accepted but not enqueued.
     *
     * We store deduplication ids for 90 days. Afterwards it is possible that the message with the
     * same deduplication id is delivered again.
     *
     * When scheduling a message, the deduplication happens before the schedule is created.
     *
     * @default undefined
     */
    deduplicationId?: string;
    /**
     * If true, the message content will get hashed and used as deduplication id.
     * If a duplicate message is detected, the request will be accepted but not enqueued.
     *
     * The content based hash includes the following values:
     *    - All headers, except Upstash-Authorization, this includes all headers you are sending.
     *    - The entire raw request body The destination from the url path
     *
     * We store deduplication ids for 90 days. Afterwards it is possible that the message with the
     * same deduplication id is delivered again.
     *
     * When scheduling a message, the deduplication happens before the schedule is created.
     *
     * @default false
     */
    contentBasedDeduplication?: boolean;
    /**
     * In case your destination server is unavaialble or returns a status code outside of the 200-299
     * range, we will retry the request after a certain amount of time.
     *
     * Configure how many times you would like the delivery to be retried
     *
     * @default The maximum retry quota associated with your account.
     */
    retries?: number;
} & ({
    /**
     * Optionally specify a cron expression to repeatedly send this message to the destination.
     *
     * @default undefined
     */
    cron: string;
} | {
    cron?: never;
});
export declare type PublishJsonRequest = Omit<PublishRequest, "body"> & {
    /**
     * The message to send.
     * This can be anything as long as it can be serialized to JSON.
     */
    body: unknown;
};
export declare type LogsRequest = {
    cursor?: number;
};
export declare type GetLogsRespone = {
    cursor?: number;
    logs: Log[];
};
export declare class Client {
    http: Requester;
    constructor(config: ClientConfig);
    /**
     * Access the topic API.
     *
     * Create, read, update or delete topics.
     */
    get topics(): Topics;
    /**
     * Access the endpoint API.
     *
     * Create, read, update or delete endpoints.
     */
    get endpoints(): Endpoints;
    /**
     * Access the message API.
     *
     * Read or cancel messages.
     */
    get messages(): Messages;
    /**
     * Access the schedule API.
     *
     * Read or delete schedules.
     */
    get schedules(): Schedules;
    publish<R extends PublishRequest>(req: R): Promise<PublishResponse<R>>;
    /**
     * publishJSON is a utility wrapper around `publish` that automatically serializes the body
     * and sets the `Content-Type` header to `application/json`.
     */
    publishJSON<R extends PublishJsonRequest = PublishJsonRequest>(req: R): Promise<PublishResponse<R>>;
    /**
     * Retrieve your logs.
     *
     * The logs endpoint is paginated and returns only 100 logs at a time.
     * If you want to receive more logs, you can use the cursor to paginate.
     *
     * The cursor is a unix timestamp with millisecond precision
     *
     * @example
     * ```ts
     * let cursor = Date.now()
     * const logs: Log[] = []
     * while (cursor > 0) {
     *   const res = await qstash.logs({ cursor })
     *   logs.push(...res.logs)
     *   cursor = res.cursor ?? 0
     * }
     * ```
     */
    logs(req?: LogsRequest): Promise<GetLogsRespone>;
}
declare type PublishResponse<PublishRequest> = PublishRequest extends {
    cron: string;
} ? {
    scheduleId: string;
} : {
    messageId: string;
};
export {};
