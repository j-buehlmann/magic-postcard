import { base64Url } from "../deps.js";
export class SignatureError extends Error {
    constructor(message) {
        super(message);
        this.name = "SignatureError";
    }
}
/**
 * Receiver offers a simlpe way to verify the signature of a request.
 */
export class Receiver {
    constructor(config) {
        Object.defineProperty(this, "currentSigningKey", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "nextSigningKey", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "subtleCrypto", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.currentSigningKey = config.currentSigningKey;
        this.nextSigningKey = config.nextSigningKey;
        this.subtleCrypto = config.subtleCrypto;
    }
    /**
     * Verify the signature of a request.
     *
     * Tries to verify the signature with the current signing key.
     * If that fails, maybe because you have rotated the keys recently, it will
     * try to verify the signature with the next signing key.
     *
     * If that fails, the signature is invalid and a `SignatureError` is thrown.
     */
    async verify(req) {
        const isValid = await this.verifyWithKey(this.currentSigningKey, req);
        if (isValid) {
            return true;
        }
        return this.verifyWithKey(this.nextSigningKey, req);
    }
    /**
     * Verify signature with a specific signing key
     */
    async verifyWithKey(key, req) {
        const parts = req.signature.split(".");
        if (parts.length !== 3) {
            throw new SignatureError("`Upstash-Signature` header is not a valid signature");
        }
        const [header, payload, signature] = parts;
        const k = await this.subtleCrypto.importKey("raw", new TextEncoder().encode(key), { name: "HMAC", hash: "SHA-256" }, false, ["sign", "verify"]);
        const isValid = await this.subtleCrypto.verify({ name: "HMAC" }, k, base64Url.decode(signature), new TextEncoder().encode(`${header}.${payload}`));
        if (!isValid) {
            throw new SignatureError("signature does not match");
        }
        const p = JSON.parse(new TextDecoder().decode(base64Url.decode(payload)));
        if (p.iss !== "Upstash") {
            throw new SignatureError(`invalid issuer: ${p.iss}`);
        }
        if (typeof req.url !== "undefined" && p.sub !== req.url) {
            throw new SignatureError(`invalid subject: ${p.sub}, want: ${req.url}`);
        }
        const now = Math.floor(Date.now() / 1000);
        if (now > p.exp) {
            console.log({ now, exp: p.exp });
            throw new SignatureError("token has expired");
        }
        if (now < p.nbf) {
            throw new SignatureError("token is not yet valid");
        }
        const bodyHash = await this.subtleCrypto.digest("SHA-256", typeof req.body === "string"
            ? new TextEncoder().encode(req.body)
            : req.body);
        const padding = new RegExp(/=+$/);
        if (p.body.replace(padding, "") !=
            base64Url.encode(bodyHash).replace(padding, "")) {
            throw new SignatureError(`body hash does not match, want: ${p.body}, got: ${base64Url.encode(bodyHash)}`);
        }
        return true;
    }
}
