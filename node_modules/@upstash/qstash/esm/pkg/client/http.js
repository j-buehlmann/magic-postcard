import { QstashError } from "./error.js";
export class HttpClient {
    constructor(config) {
        Object.defineProperty(this, "baseUrl", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "authorization", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "options", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "retry", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.baseUrl = config.baseUrl.replace(/\/$/, "");
        this.authorization = config.authorization;
        if (typeof config?.retry === "boolean" && config?.retry === false) {
            this.retry = {
                attempts: 1,
                backoff: () => 0,
            };
        }
        else {
            this.retry = {
                attempts: config?.retry?.retries ?? 5,
                backoff: config?.retry?.backoff ??
                    ((retryCount) => Math.exp(retryCount) * 50),
            };
        }
    }
    async request(req) {
        const headers = new Headers(req.headers);
        headers.set("Authorization", this.authorization);
        const requestOptions = {
            method: req.method,
            headers,
            body: req.body,
            keepalive: req.keepalive,
        };
        const url = new URL([this.baseUrl, ...(req.path ?? [])].join("/"));
        if (req.query) {
            for (const [key, value] of Object.entries(req.query)) {
                if (typeof value !== "undefined") {
                    url.searchParams.set(key, value.toString());
                }
            }
        }
        let res = null;
        let error = null;
        for (let i = 0; i <= this.retry.attempts; i++) {
            try {
                res = await fetch(url.toString(), requestOptions);
                break;
            }
            catch (err) {
                error = err;
                await new Promise((r) => setTimeout(r, this.retry.backoff(i)));
            }
        }
        if (!res) {
            throw error ?? new Error("Exhausted all retries");
        }
        if (res.status < 200 || res.status >= 300) {
            throw new QstashError(await res.text() ?? res.statusText);
        }
        return (await res.json());
    }
}
