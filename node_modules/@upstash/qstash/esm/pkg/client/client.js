import { HttpClient } from "./http.js";
import { Topics } from "./topics.js";
import { Messages } from "./messages.js";
import { Schedules } from "./schedules.js";
import { Endpoints } from "./endpoints.js";
export class Client {
    constructor(config) {
        Object.defineProperty(this, "http", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.http = new HttpClient({
            baseUrl: config.baseUrl
                ? config.baseUrl.replace(/\/$/, "")
                : "https://qstash.upstash.io",
            authorization: `Bearer ${config.token}`,
        });
    }
    /**
     * Access the topic API.
     *
     * Create, read, update or delete topics.
     */
    get topics() {
        return new Topics(this.http);
    }
    /**
     * Access the endpoint API.
     *
     * Create, read, update or delete endpoints.
     */
    get endpoints() {
        return new Endpoints(this.http);
    }
    /**
     * Access the message API.
     *
     * Read or cancel messages.
     */
    get messages() {
        return new Messages(this.http);
    }
    /**
     * Access the schedule API.
     *
     * Read or delete schedules.
     */
    get schedules() {
        return new Schedules(this.http);
    }
    async publish(req) {
        const destination = req.url ?? req.topic;
        if (!destination) {
            throw new Error("Either url or topic must be set");
        }
        const headers = new Headers(req.headers);
        if (req.delay) {
            headers.set("Upstash-Delay", `${req.delay.toFixed()}s`);
        }
        if (req.notBefore) {
            headers.set("Upstash-Not-Before", req.notBefore.toFixed());
        }
        if (req.deduplicationId) {
            headers.set("Upstash-Deduplication-Id", req.deduplicationId);
        }
        if (req.contentBasedDeduplication) {
            headers.set("Upstash-Content-Based-Deduplication", "true");
        }
        if (req.retries) {
            headers.set("Upstash-Retries", req.retries.toFixed());
        }
        if (req.cron) {
            headers.set("Upstash-Cron", req.cron);
        }
        const res = await this.http.request({
            path: ["v1", "publish", destination],
            body: req.body,
            headers,
            method: "POST",
        });
        return res;
    }
    /**
     * publishJSON is a utility wrapper around `publish` that automatically serializes the body
     * and sets the `Content-Type` header to `application/json`.
     */
    async publishJSON(req) {
        const headers = new Headers(req.headers);
        headers.set("Content-Type", "application/json");
        const res = await this.publish({
            ...req,
            headers,
            body: JSON.stringify(req.body),
        });
        return res;
    }
    /**
     * Retrieve your logs.
     *
     * The logs endpoint is paginated and returns only 100 logs at a time.
     * If you want to receive more logs, you can use the cursor to paginate.
     *
     * The cursor is a unix timestamp with millisecond precision
     *
     * @example
     * ```ts
     * let cursor = Date.now()
     * const logs: Log[] = []
     * while (cursor > 0) {
     *   const res = await qstash.logs({ cursor })
     *   logs.push(...res.logs)
     *   cursor = res.cursor ?? 0
     * }
     * ```
     */
    async logs(req) {
        const query = {};
        if (req?.cursor && req.cursor > 0) {
            query["cursor"] = req.cursor;
        }
        const res = await this.http.request({
            path: ["v1", "logs"],
            method: "GET",
            query,
        });
        return res;
    }
}
